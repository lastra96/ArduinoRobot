//ultrasonidos
const int Trigger = 2;   //Pin digital 2 para el Trigger del sensor
const int Echo = 3;   //Pin digital 3 para el echo del sensor

//I2c - Pantalla
#include <Wire.h> 
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x3F,16,2);

//led
const int ledPIN = 9;

//motores
const int motord1 = 12;
const int motorv1 = 10;
const int motord2 = 13;
const int motorv2 = 11;

//interrupciones
const int intPin = 2;

//mando
#include <IRremote.h>
 
const int KEY_UP = 0xFF629D;
const int KEY_LEFT = 0xFF22DD;
const int KEY_OK = 0xFF02FD;
const int KEY_RIGHT = 0xFFC23D;
const int KEY_DOWN = 0xFFA857;
const int RECV_PIN = 9;
IRrecv irrecv(RECV_PIN);
decode_results results;

int com[30];
int inic = 1;
int i=0;
int mode = 1;
int errormode = 0;
String errortext = "Unknown error";
int obstaculos = 0;




//-------------------------------------------------------------------------------------------



void setup() {
	Serial.begin(9600);//iniciailzamos la comunicación
	//ultrasonidos
	pinMode(Trigger, OUTPUT); //pin como salida
	pinMode(Echo, INPUT);  //pin como entrada
	digitalWrite(Trigger, LOW);//Inicializamos el pin con 0
	  
	//LCD
	lcd.init();
	lcd.backlight();//Encender la luz de fondo.
	 
	//led
	pinMode(ledPIN , OUTPUT);  //definir pin como salida

	//mando
	irrecv.enableIRIn();

	//motores
	pinMode(motord1, OUTPUT);
	pinMode(motorv1, OUTPUT);
	pinMode(motord2, OUTPUT);
	pinMode(motorv2, OUTPUT);

	//interrupciones
	pinMode(intPin, INPUT_PULLUP);
	attachInterrupt(digitalPinToInterrupt(intPin), interruptCount, LOW);
  
}




//-------------------------------------------------------------------------------------------

void loop() {

	switch(mode){
		case 1:
			mensaje("Introduce comandos","");
			if(recibeComandos()==TRUE){
				mensaje("Recepción correcta", "Comenzando");
				delay(3000);
				mensaje("","");
				delay(1000);
				mode=2;
			}else{
				errormode=1;
				errortext="Error en recepción";
				mode=5;
			}
				
		break;
		case 2;
			mensaje("Ejecutando..","");
			for(int i=0; i< com.length(); i++){
				if(cercaObjeto()==FALSE){
					if(ejecuta(com[i])==FALSE){
						errormode=2;
						errortext="Error en ejecución";
						i=com.length();
						mode=5;
					}
				}else{
					obstaculo();
				}
			}
				
		break;
		case 3:
			mensaje("Fin de la lista","retomar?");
			if(retomar()){
				mode=1;
				mensaje("retomando...","");
				delay(1500);
			}


		break;
		case 4:
			switch(errormode){
				case 1:
					mensaje(errortext,"Vuelva a empezar");
					delay(3000);
					mode=1;
				break;
				case 2:
					mensaje(errortext,"Vuelva a empezar");
					delay(3000);
					mode=1;
				break;
				default:
					mensaje("ERROR","REINTENTANDO...");	
					delay(3000);
					mode=1;
			}

		break;
		default:
			mode=1;
	}
}



//------------------------------------------------------------------------




boolean retomar(){
	if (irrecv.decode(&results)){
		if(results.value==KEY_OK){
			return TRUE;
		}else if(results.value!=NULL){
			mensaje("Vuelva a intentarlo","");
		}
	}
	return FALSE;
}

void obstaculo(){
	mensaje("Obstáculo encontrado", "Girando...");
	enciendeLed(200);
	delay(200);
	enciendeLed(200);
	delay(200);
	enciendeLed(200);
	ejecuta(0);
	obstaculos++;
	String m = obstaculos + "obs encontrados"
	mensaje("Continuando ruta",m);
}


void mensaje(String a, String b){
	lcd.setCursor(0,0);
	lcd.print(a);
	lcd.setCursor(0,1);// Cursor en la primera posición de la 2° fila
	lcd.print(b);
}

long distancia(){
	long t; //timepo que demora en llegar el eco
	long d; //distancia en centimetros
	digitalWrite(Trigger, HIGH);
	delayMicroseconds(10);          //Enviamos un pulso de 10us
	digitalWrite(Trigger, LOW);
	t = pulseIn(Echo, HIGH); //obtenemos el ancho del pulso
	d = t/59; 
	return d;
}

boolean cercaObjeto(){
	if(distancia()<=30){
		delay(500);
		if(distancia()<=25){
			return true;
		}
	}
	return false;
}

void enciendeLed(long ms){
	digitalWrite(ledPIN , HIGH);   
	delay(ms);                   
	digitalWrite(ledPIN , LOW);    
}

boolean recibeComandos(){
	int flag=0;
	while(flag==0)
	{
		if (irrecv.decode(&results))
		{
			switch (results.value)
			{
				case KEY_UP:
					 com[i]=1;
					 i++;
				break;
				case KEY_LEFT:
					 com[i]=2;
					 i++;
				break;
				case KEY_RIGHT:
					 com[i]=3;
					 i++;
				break;
				case KEY_DOWN:
					 com[i]=4;
					 i++;
				break;
				case KEY_OK:
					 flag=1;
				break;
				default:
					return false;
					break;
			}
			irrecv.resume();
		}
	}
	return true;
}

boolean ejecuta (int x){
	switch (x){
		case 2:
			//alante
			digitalWrite(motord1, HIGH);
			digitalWrite(motord2, LOW);
			digitalWrite(motorv1, 50);
			digitalWrite(motorv2, 50);
			delay(1000);
			digitalWrite(motorv1, 0);
			digitalWrite(motorv2, 0);

		break;
		case 4:
			//izda
			digitalWrite(motord1, HIGH);
			digitalWrite(motord2, LOW);
			digitalWrite(motorv1, 0);
			digitalWrite(motorv2, 50);
			delay(1000);
			digitalWrite(motorv1, 0);
			digitalWrite(motorv2, 0);

		break;
		case 6:
			//dcha
			digitalWrite(motord1, HIGH);
			digitalWrite(motord2, LOW);
			digitalWrite(motorv1, 50);
			digitalWrite(motorv2, 0);
			delay(1000);
			digitalWrite(motorv1, 0);
			digitalWrite(motorv2, 0);

		break;
		case 8:
			//atras
			digitalWrite(motord1, LOW);
			digitalWrite(motord2, HIGH);
			digitalWrite(motorv1, 50);
			digitalWrite(motorv2, 50);
			delay(1000);
			digitalWrite(motorv1, 0);
			digitalWrite(motorv2, 0);

		break;
		case 0:
			//media vuelta
			digitalWrite(motord1, LOW);
			digitalWrite(motord2, LOW);
			digitalWrite(motorv1, 50);
			digitalWrite(motorv2, 50);
			delay(1000);
			digitalWrite(motorv1, 0);
			digitalWrite(motorv2, 0);

		break;
		default:
		//error
		return false;
	}
	return true;
}

void interruptCount()
{
   //interrupcion
}

